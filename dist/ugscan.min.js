import*as e from"three";import{Loader as t,LoaderUtils as n,FileLoader as o,RepeatWrapping as s,Color as i,MeshPhongMaterial as r,Vector2 as a,Texture as c,sRGBEncoding as l,Vector3 as h,Group as d,BufferGeometry as u,Float32BufferAttribute as p,LineBasicMaterial as m,Material as f,PointsMaterial as b,LineSegments as g,Points as y,Mesh as w,EventDispatcher as v,MOUSE as E,TOUCH as L,Quaternion as T,Spherical as k,SRGBColorSpace as O,LinearSRGBColorSpace as A,BufferAttribute as x}from"three";class P extends t{constructor(e){super(e)}load(e,t,s,i){const r=this,a=""===this.path?n.extractUrlBase(e):this.path,c=new o(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials);let l=this.fileMap.get(e);this.zip.file(l).async("string").then((function(n){try{t(r.parse(n,a))}catch(t){i?i(t):console.error(t),r.manager.itemError(e)}}),s,i)}setMaterialOptions(e){return this.materialOptions=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const n=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(n,e.files[t].name)}return this}parse(e,t){const n=e.split("\n");let o={};const s=/\s+/,i={};for(let e=0;e<n.length;e++){let t=n[e];if(t=t.trim(),0===t.length||"#"===t.charAt(0))continue;const r=t.indexOf(" ");let a=r>=0?t.substring(0,r):t;a=a.toLowerCase();let c=r>=0?t.substring(r+1):"";if(c=c.trim(),"newmtl"===a)o={name:c},i[c]=o;else if("ka"===a||"kd"===a||"ks"===a||"ke"===a){const e=c.split(s,3);o[a]=[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]}else o[a]=c}const r=new j(this.resourcePath||t,this.materialOptions);return r.setCrossOrigin(this.crossOrigin),r.setManager(this.manager),r.setMaterials(i),r.setFileMap(this.fileMap),r.setZip(this.zip),r}}class j{constructor(e="",t={}){this.baseUrl=e,this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.wrap=void 0!==this.options.wrap?this.options.wrap:s}setFileMap(e){this.fileMap=e}setZip(e){this.zip=e}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const t={};for(const n in e){const o=e[n],s={};t[n]=s;for(const e in o){let t=!0,n=o[e];const i=e.toLowerCase();switch(i){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(n=[n[0]/255,n[1]/255,n[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===n[0]&&0===n[1]&&0===n[2]&&(t=!1)}t&&(s[i]=n)}}return t}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray}create(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const t=this,n=this.materialsInfo[e],o={name:e,side:this.side};function s(e,n){if(o[e])return;const s=t.getTextureParams(n,o),i=t.loadTexture(s.url);i.repeat.copy(s.scale),i.offset.copy(s.offset),i.wrapS=t.wrap,i.wrapT=t.wrap,"map"!==e&&"emissiveMap"!==e||(i.encoding=l),o[e]=i}for(const e in n){const t=n[e];let r;if(""!==t)switch(e.toLowerCase()){case"kd":o.color=(new i).fromArray(t).convertSRGBToLinear();break;case"ks":o.specular=(new i).fromArray(t).convertSRGBToLinear();break;case"ke":o.emissive=(new i).fromArray(t).convertSRGBToLinear();break;case"map_kd":s("map",t);break;case"map_ks":s("specularMap",t);break;case"map_ke":s("emissiveMap",t);break;case"norm":s("normalMap",t);break;case"map_bump":case"bump":s("bumpMap",t);break;case"map_d":s("alphaMap",t),o.transparent=!0;break;case"ns":o.shininess=parseFloat(t);break;case"d":r=parseFloat(t),r<1&&(o.opacity=r,o.transparent=!0);break;case"tr":r=parseFloat(t),this.options&&this.options.invertTrProperty&&(r=1-r),r>0&&(o.opacity=1-r,o.transparent=!0)}}return this.materials[e]=new r(o),this.materials[e]}getTextureParams(e,t){const n={scale:new a(1,1),offset:new a(0,0)},o=e.split(/\s+/);let s;return s=o.indexOf("-bm"),s>=0&&(t.bumpScale=parseFloat(o[s+1]),o.splice(s,2)),s=o.indexOf("-s"),s>=0&&(n.scale.set(parseFloat(o[s+1]),parseFloat(o[s+2])),o.splice(s,4)),s=o.indexOf("-o"),s>=0&&(n.offset.set(parseFloat(o[s+1]),parseFloat(o[s+2])),o.splice(s,4)),n.url=o.join(" ").trim(),n}loadTexture(e,t,n,o,s){const i=new c;let r=this.fileMap.get(e);return this.zip.file(r).async("blob").then((e=>{const t=new Image;t.src=URL.createObjectURL(e),i.image=t,i.needsUpdate=!0,void 0!==n&&n(i)})),void 0!==t&&(i.mapping=t),i}}const M=/^[og]\s*(.+)?/,_=/^mtllib /,I=/^usemtl /,C=/^usemap /,R=/\s+/,D=new h,N=new h,S=new h,U=new h,F=new h,z=new i;function V(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const n=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){const n=this._finalize(!1);n&&(n.inherited||n.groupCount<=0)&&this.materials.splice(n.index,1);const o={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==n?n.smooth:this.smooth,groupStart:void 0!==n?n.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(o),o},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},n&&n.name&&"function"==typeof n.clone){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseNormalIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseUVIndex:function(e,t){const n=parseInt(e,10);return 2*(n>=0?n-1:n+t/2)},addVertex:function(e,t,n){const o=this.vertices,s=this.object.geometry.vertices;s.push(o[e+0],o[e+1],o[e+2]),s.push(o[t+0],o[t+1],o[t+2]),s.push(o[n+0],o[n+1],o[n+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,n){const o=this.normals,s=this.object.geometry.normals;s.push(o[e+0],o[e+1],o[e+2]),s.push(o[t+0],o[t+1],o[t+2]),s.push(o[n+0],o[n+1],o[n+2])},addFaceNormal:function(e,t,n){const o=this.vertices,s=this.object.geometry.normals;D.fromArray(o,e),N.fromArray(o,t),S.fromArray(o,n),F.subVectors(S,N),U.subVectors(D,N),F.cross(U),F.normalize(),s.push(F.x,F.y,F.z),s.push(F.x,F.y,F.z),s.push(F.x,F.y,F.z)},addColor:function(e,t,n){const o=this.colors,s=this.object.geometry.colors;void 0!==o[e]&&s.push(o[e+0],o[e+1],o[e+2]),void 0!==o[t]&&s.push(o[t+0],o[t+1],o[t+2]),void 0!==o[n]&&s.push(o[n+0],o[n+1],o[n+2])},addUV:function(e,t,n){const o=this.uvs,s=this.object.geometry.uvs;s.push(o[e+0],o[e+1]),s.push(o[t+0],o[t+1]),s.push(o[n+0],o[n+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,n,o,s,i,r,a,c){const l=this.vertices.length;let h=this.parseVertexIndex(e,l),d=this.parseVertexIndex(t,l),u=this.parseVertexIndex(n,l);if(this.addVertex(h,d,u),this.addColor(h,d,u),void 0!==r&&""!==r){const e=this.normals.length;h=this.parseNormalIndex(r,e),d=this.parseNormalIndex(a,e),u=this.parseNormalIndex(c,e),this.addNormal(h,d,u)}else this.addFaceNormal(h,d,u);if(void 0!==o&&""!==o){const e=this.uvs.length;h=this.parseUVIndex(o,e),d=this.parseUVIndex(s,e),u=this.parseUVIndex(i,e),this.addUV(h,d,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,o=e.length;n<o;n++){const o=this.parseVertexIndex(e[n],t);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const n=this.vertices.length,o=this.uvs.length;for(let t=0,o=e.length;t<o;t++)this.addVertexLine(this.parseVertexIndex(e[t],n));for(let e=0,n=t.length;e<n;e++)this.addUVLine(this.parseUVIndex(t[e],o))}};return e.startObject("",!1),e}let H=class extends t{constructor(e){super(e),this.materials=null}load(e,t,n,s){const i=this,r=new o(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);let a=this.fileMap.get(e);this.zip.file(a).async("uint8array").then((function(n){try{t(i.parse(n))}catch(t){s?s(t):console.error(t),i.manager.itemError(e)}}),n,s)}setMaterials(e){return this.materials=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const n=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(n,e.files[t].name)}return this}parse(e){const t=new V;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));const n=e.split("\n");let o=[];for(let e=0,s=n.length;e<s;e++){const s=n[e].trimStart();if(0===s.length)continue;const i=s.charAt(0);if("#"!==i)if("v"===i){const e=s.split(R);switch(e[0]){case"v":t.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?(z.setRGB(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6])).convertSRGBToLinear(),t.colors.push(z.r,z.g,z.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":t.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===i){const e=s.slice(1).trim().split(R),n=[];for(let t=0,o=e.length;t<o;t++){const o=e[t];if(o.length>0){const e=o.split("/");n.push(e)}}const o=n[0];for(let e=1,s=n.length-1;e<s;e++){const s=n[e],i=n[e+1];t.addFace(o[0],s[0],i[0],o[1],s[1],i[1],o[2],s[2],i[2])}}else if("l"===i){const e=s.substring(1).trim().split(" ");let n=[];const o=[];if(-1===s.indexOf("/"))n=e;else for(let t=0,s=e.length;t<s;t++){const s=e[t].split("/");""!==s[0]&&n.push(s[0]),""!==s[1]&&o.push(s[1])}t.addLineGeometry(n,o)}else if("p"===i){const e=s.slice(1).trim().split(" ");t.addPointGeometry(e)}else if(null!==(o=M.exec(s))){const e=(" "+o[0].slice(1).trim()).slice(1);t.startObject(e)}else if(I.test(s))t.object.startMaterial(s.substring(7).trim(),t.materialLibraries);else if(_.test(s))t.materialLibraries.push(s.substring(7).trim());else if(C.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===i){if(o=s.split(" "),o.length>1){const e=o[1].trim().toLowerCase();t.object.smooth="0"!==e&&"off"!==e}else t.object.smooth=!0;const e=t.object.currentMaterial();e&&(e.smooth=t.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}}t.finalize();const s=new d;s.materialLibraries=[].concat(t.materialLibraries);if(!0===!(1===t.objects.length&&0===t.objects[0].geometry.vertices.length))for(let e=0,n=t.objects.length;e<n;e++){const n=t.objects[e],o=n.geometry,i=n.materials,a="Line"===o.type,c="Points"===o.type;let l=!1;if(0===o.vertices.length)continue;const h=new u;h.setAttribute("position",new p(o.vertices,3)),o.normals.length>0&&h.setAttribute("normal",new p(o.normals,3)),o.colors.length>0&&(l=!0,h.setAttribute("color",new p(o.colors,3))),!0===o.hasUVIndices&&h.setAttribute("uv",new p(o.uvs,2));const d=[];for(let e=0,n=i.length;e<n;e++){const n=i[e],o=n.name+"_"+n.smooth+"_"+l;let s=t.materials[o];if(null!==this.materials)if(s=this.materials.create(n.name),!a||!s||s instanceof m){if(c&&s&&!(s instanceof b)){const e=new b({size:10,sizeAttenuation:!1});f.prototype.copy.call(e,s),e.color.copy(s.color),e.map=s.map,s=e}}else{const e=new m;f.prototype.copy.call(e,s),e.color.copy(s.color),s=e}void 0===s&&(s=a?new m:c?new b({size:1,sizeAttenuation:!1}):new r,s.name=n.name,s.flatShading=!n.smooth,s.vertexColors=l,t.materials[o]=s),d.push(s)}let v;if(d.length>1){for(let e=0,t=i.length;e<t;e++){const t=i[e];h.addGroup(t.groupStart,t.groupCount,e)}v=a?new g(h,d):c?new y(h,d):new w(h,d)}else v=a?new g(h,d[0]):c?new y(h,d[0]):new w(h,d[0]);v.name=n.name,s.add(v)}else if(t.vertices.length>0){const e=new b({size:1,sizeAttenuation:!1}),n=new u;n.setAttribute("position",new p(t.vertices,3)),t.colors.length>0&&void 0!==t.colors[0]&&(n.setAttribute("color",new p(t.colors,3)),e.vertexColors=!0);const o=new y(n,e);s.add(o)}return s}};const Y={type:"change"},G={type:"start"},Z={type:"end"};class B extends v{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new h,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:E.ROTATE,MIDDLE:E.DOLLY,RIGHT:E.PAN},this.touches={ONE:L.ROTATE,TWO:L.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",J),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",J),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Y),n.update(),s=o.NONE},this.update=function(){const t=new h,a=(new T).setFromUnitVectors(e.up,new h(0,1,0)),p=a.clone().invert(),m=new h,f=new T,b=2*Math.PI;return function(){const e=n.object.position;t.copy(e).sub(n.target),t.applyQuaternion(a),r.setFromVector3(t),n.autoRotate&&s===o.NONE&&j(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(r.theta+=c.theta*n.dampingFactor,r.phi+=c.phi*n.dampingFactor):(r.theta+=c.theta,r.phi+=c.phi);let h=n.minAzimuthAngle,g=n.maxAzimuthAngle;return isFinite(h)&&isFinite(g)&&(h<-Math.PI?h+=b:h>Math.PI&&(h-=b),g<-Math.PI?g+=b:g>Math.PI&&(g-=b),r.theta=h<=g?Math.max(h,Math.min(g,r.theta)):r.theta>(h+g)/2?Math.max(h,r.theta):Math.min(g,r.theta)),r.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,r.phi)),r.makeSafe(),r.radius*=l,r.radius=Math.max(n.minDistance,Math.min(n.maxDistance,r.radius)),!0===n.enableDamping?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),t.setFromSpherical(r),t.applyQuaternion(p),e.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(c.theta*=1-n.dampingFactor,c.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(c.set(0,0,0),d.set(0,0,0)),l=1,!!(u||m.distanceToSquared(n.object.position)>i||8*(1-f.dot(n.object.quaternion))>i)&&(n.dispatchEvent(Y),m.copy(n.object.position),f.copy(n.object.quaternion),u=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Q),n.domElement.removeEventListener("pointerdown",K),n.domElement.removeEventListener("pointercancel",W),n.domElement.removeEventListener("wheel",q),n.domElement.removeEventListener("pointermove",X),n.domElement.removeEventListener("pointerup",W),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",J),n._domElementKeyEvents=null)};const n=this,o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=o.NONE;const i=1e-6,r=new k,c=new k;let l=1;const d=new h;let u=!1;const p=new a,m=new a,f=new a,b=new a,g=new a,y=new a,w=new a,v=new a,O=new a,A=[],x={};function P(){return Math.pow(.95,n.zoomSpeed)}function j(e){c.theta-=e}function M(e){c.phi-=e}const _=function(){const e=new h;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),d.add(e)}}(),I=function(){const e=new h;return function(t,o){!0===n.screenSpacePanning?e.setFromMatrixColumn(o,1):(e.setFromMatrixColumn(o,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),d.add(e)}}(),C=function(){const e=new h;return function(t,o){const s=n.domElement;if(n.object.isPerspectiveCamera){const i=n.object.position;e.copy(i).sub(n.target);let r=e.length();r*=Math.tan(n.object.fov/2*Math.PI/180),_(2*t*r/s.clientHeight,n.object.matrix),I(2*o*r/s.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(_(t*(n.object.right-n.object.left)/n.object.zoom/s.clientWidth,n.object.matrix),I(o*(n.object.top-n.object.bottom)/n.object.zoom/s.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function R(e){n.object.isPerspectiveCamera?l/=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*e)),n.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function D(e){n.object.isPerspectiveCamera?l*=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/e)),n.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function N(e){p.set(e.clientX,e.clientY)}function S(e){b.set(e.clientX,e.clientY)}function U(){if(1===A.length)p.set(A[0].pageX,A[0].pageY);else{const e=.5*(A[0].pageX+A[1].pageX),t=.5*(A[0].pageY+A[1].pageY);p.set(e,t)}}function F(){if(1===A.length)b.set(A[0].pageX,A[0].pageY);else{const e=.5*(A[0].pageX+A[1].pageX),t=.5*(A[0].pageY+A[1].pageY);b.set(e,t)}}function z(){const e=A[0].pageX-A[1].pageX,t=A[0].pageY-A[1].pageY,n=Math.sqrt(e*e+t*t);w.set(0,n)}function V(e){if(1==A.length)m.set(e.pageX,e.pageY);else{const t=ee(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);m.set(n,o)}f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const t=n.domElement;j(2*Math.PI*f.x/t.clientHeight),M(2*Math.PI*f.y/t.clientHeight),p.copy(m)}function H(e){if(1===A.length)g.set(e.pageX,e.pageY);else{const t=ee(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);g.set(n,o)}y.subVectors(g,b).multiplyScalar(n.panSpeed),C(y.x,y.y),b.copy(g)}function B(e){const t=ee(e),o=e.pageX-t.x,s=e.pageY-t.y,i=Math.sqrt(o*o+s*s);v.set(0,i),O.set(0,Math.pow(v.y/w.y,n.zoomSpeed)),R(O.y),w.copy(v)}function K(e){!1!==n.enabled&&(0===A.length&&(n.domElement.setPointerCapture(e.pointerId),n.domElement.addEventListener("pointermove",X),n.domElement.addEventListener("pointerup",W)),function(e){A.push(e)}(e),"touch"===e.pointerType?function(e){switch($(e),A.length){case 1:switch(n.touches.ONE){case L.ROTATE:if(!1===n.enableRotate)return;U(),s=o.TOUCH_ROTATE;break;case L.PAN:if(!1===n.enablePan)return;F(),s=o.TOUCH_PAN;break;default:s=o.NONE}break;case 2:switch(n.touches.TWO){case L.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&z(),n.enablePan&&F(),s=o.TOUCH_DOLLY_PAN;break;case L.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&z(),n.enableRotate&&U(),s=o.TOUCH_DOLLY_ROTATE;break;default:s=o.NONE}break;default:s=o.NONE}s!==o.NONE&&n.dispatchEvent(G)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case E.DOLLY:if(!1===n.enableZoom)return;!function(e){w.set(e.clientX,e.clientY)}(e),s=o.DOLLY;break;case E.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;S(e),s=o.PAN}else{if(!1===n.enableRotate)return;N(e),s=o.ROTATE}break;case E.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;N(e),s=o.ROTATE}else{if(!1===n.enablePan)return;S(e),s=o.PAN}break;default:s=o.NONE}s!==o.NONE&&n.dispatchEvent(G)}(e))}function X(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch($(e),s){case o.TOUCH_ROTATE:if(!1===n.enableRotate)return;V(e),n.update();break;case o.TOUCH_PAN:if(!1===n.enablePan)return;H(e),n.update();break;case o.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&B(e),n.enablePan&&H(e)}(e),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&B(e),n.enableRotate&&V(e)}(e),n.update();break;default:s=o.NONE}}(e):function(e){switch(s){case o.ROTATE:if(!1===n.enableRotate)return;!function(e){m.set(e.clientX,e.clientY),f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const t=n.domElement;j(2*Math.PI*f.x/t.clientHeight),M(2*Math.PI*f.y/t.clientHeight),p.copy(m),n.update()}(e);break;case o.DOLLY:if(!1===n.enableZoom)return;!function(e){v.set(e.clientX,e.clientY),O.subVectors(v,w),O.y>0?R(P()):O.y<0&&D(P()),w.copy(v),n.update()}(e);break;case o.PAN:if(!1===n.enablePan)return;!function(e){g.set(e.clientX,e.clientY),y.subVectors(g,b).multiplyScalar(n.panSpeed),C(y.x,y.y),b.copy(g),n.update()}(e)}}(e))}function W(e){!function(e){delete x[e.pointerId];for(let t=0;t<A.length;t++)if(A[t].pointerId==e.pointerId)return void A.splice(t,1)}(e),0===A.length&&(n.domElement.releasePointerCapture(e.pointerId),n.domElement.removeEventListener("pointermove",X),n.domElement.removeEventListener("pointerup",W)),n.dispatchEvent(Z),s=o.NONE}function q(e){!1!==n.enabled&&!1!==n.enableZoom&&s===o.NONE&&(e.preventDefault(),n.dispatchEvent(G),function(e){e.deltaY<0?D(P()):e.deltaY>0&&R(P()),n.update()}(e),n.dispatchEvent(Z))}function J(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?M(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):C(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?M(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):C(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?j(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):C(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?j(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):C(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function Q(e){!1!==n.enabled&&e.preventDefault()}function $(e){let t=x[e.pointerId];void 0===t&&(t=new a,x[e.pointerId]=t),t.set(e.pageX,e.pageY)}function ee(e){const t=e.pointerId===A[0].pointerId?A[1]:A[0];return x[t.pointerId]}n.domElement.addEventListener("contextmenu",Q),n.domElement.addEventListener("pointerdown",K),n.domElement.addEventListener("pointercancel",W),n.domElement.addEventListener("wheel",q,{passive:!1}),this.update()}}const K=new WeakMap;class X extends t{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const n=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(n,e.files[t].name)}return this}load(e,t,n,o){var s=this;let i=this.fileMap.get(e);s.zip.file(i).async("arraybuffer").then((function(e){s.parse(e,t,o)}),n,o)}parse(e,t,n){this.decodeDracoFile(e,t,null,null,O).catch(n)}decodeDracoFile(e,t,n,o,s=A){const i={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:o||this.defaultAttributeTypes,useUniqueIDs:!!n,vertexColorSpace:s};return this.decodeGeometry(e,i).then(t)}decodeGeometry(e,t){const n=JSON.stringify(t);if(K.has(e)){const t=K.get(e);if(t.key===n)return t.promise;if(0===e.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let o;const s=this.workerNextTaskID++,i=e.byteLength,r=this._getWorker(s,i).then((n=>(o=n,new Promise(((n,i)=>{o._callbacks[s]={resolve:n,reject:i},o.postMessage({type:"decode",id:s,taskConfig:t,buffer:e},[e])}))))).then((e=>this._createGeometry(e.geometry)));return r.catch((()=>!0)).then((()=>{o&&s&&this._releaseTask(o,s)})),K.set(e,{key:n,promise:r}),r}_createGeometry(e){const t=new u;e.index&&t.setIndex(new x(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const o=e.attributes[n],s=o.name,i=o.array,r=o.itemSize,a=new x(i,r);"color"===s&&this._assignVertexColorSpace(a,o.vertexColorSpace),t.setAttribute(s,a)}return t}_assignVertexColorSpace(e,t){if(t!==O)return;const n=new i;for(let t=0,o=e.count;t<o;t++)n.fromBufferAttribute(e,t).convertSRGBToLinear(),e.setXYZ(t,n.r,n.g,n.b)}_loadLibrary(e,t){const n=new o(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise(((t,o)=>{n.load(e,t,void 0,o)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then((t=>{const n=t[0];e||(this.decoderConfig.wasmBinary=t[1]);const o=W.toString(),s=["/* draco decoder */",n,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([s]))})),this.decoderPending}_getWorker(e,t){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",decoderConfig:this.decoderConfig}),e.onmessage=function(t){const n=t.data;switch(n.type){case"decode":e._callbacks[n.id].resolve(n);break;case"error":e._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function W(){let e,t;function n(e,t,n,o,s,i){const r=i.num_components(),a=n.num_points()*r,c=a*s.BYTES_PER_ELEMENT,l=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),h=e._malloc(c);t.GetAttributeDataArrayForAllPoints(n,i,l,c,h);const d=new s(e.HEAPF32.buffer,h,a).slice();return e._free(h),{name:o,array:d,itemSize:r}}onmessage=function(o){const s=o.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const o=s.buffer,i=s.taskConfig;t.then((e=>{const t=e.draco,r=new t.Decoder;try{const e=function(e,t,o,s){const i=s.attributeIDs,r=s.attributeTypes;let a,c;const l=t.GetEncodedGeometryType(o);if(l===e.TRIANGULAR_MESH)a=new e.Mesh,c=t.DecodeArrayToMesh(o,o.byteLength,a);else{if(l!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");a=new e.PointCloud,c=t.DecodeArrayToPointCloud(o,o.byteLength,a)}if(!c.ok()||0===a.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const h={index:null,attributes:[]};for(const o in i){const c=self[r[o]];let l,d;if(s.useUniqueIDs)d=i[o],l=t.GetAttributeByUniqueId(a,d);else{if(d=t.GetAttributeId(a,e[i[o]]),-1===d)continue;l=t.GetAttribute(a,d)}const u=n(e,t,a,o,c,l);"color"===o&&(u.vertexColorSpace=s.vertexColorSpace),h.attributes.push(u)}l===e.TRIANGULAR_MESH&&(h.index=function(e,t,n){const o=n.num_faces(),s=3*o,i=4*s,r=e._malloc(i);t.GetTrianglesUInt32Array(n,i,r);const a=new Uint32Array(e.HEAPF32.buffer,r,s).slice();return e._free(r),{array:a,itemSize:1}}(e,t,a));return e.destroy(a),h}(t,r,new Int8Array(o),i),a=e.attributes.map((e=>e.array.buffer));e.index&&a.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},a)}catch(e){console.error(e),self.postMessage({type:"error",id:s.id,error:e.message})}finally{t.destroy(r)}}))}}}class q{#e="0c4fadf7f33cf284889ba31718b86d3513dd391ca6a2ab8debbf5855f4cb72b7";#t="6d15b55292b430789704bb164179efd98fb146c5d123f3ad0285f47364fc0657";#n=null;#o=null;#s=null;constructor(e){this.#s=e}initConfig(e){var t,n;e?(t=CloudKit.DEVELOPMENT_ENVIRONMENT,n=this.#e):(t=CloudKit.PRODUCTION_ENVIRONMENT,n=this.#t),CloudKit.configure({containers:[{containerIdentifier:"iCloud.com.ugscan",apiTokenAuth:{apiToken:n},environment:t}]}),this.#n=CloudKit.getDefaultContainer(),this.#o=this.#n.publicCloudDatabase}downloadZipFromURL(e){let t=this;new JSZip,fetch(e).then((e=>{const n=e.headers.get("content-length");let o=0;const s=e.body.getReader(),i=[];!function e(){s.read().then((({done:s,value:r})=>{if(s){const e=new Blob(i),n=new FileReader;return n.onload=function(){(new JSZip).loadAsync(n.result).then((e=>{t.loadUGB(e,t.zoomTo,t.#s)}))},void n.readAsArrayBuffer(e)}i.push(r),o+=r.byteLength,t.onProgress(o,n),e()})).catch((e=>{console.error(e)}))}()})).catch((e=>{console.error(e)}))}loadOBJ(e){const t=function(e){e.lengthComputable&&(e.loaded,e.total)};(new P).setZip(e).load("TexturedMeshSimplified.mtl",(function(n){n.preload(),(new OBJLoader).setMaterials(n).setZip(e).load("TexturedMeshSimplified.obj",(function(e){scene.add(e),zoomTo(e)}),t)}))}loadUGB(t,n,o){let s=this;const i=function(e){if(e.lengthComputable){const t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% downloaded")}};(new P).setZip(t).load("TexturedMeshSimplified.mtl",(function(r){r.preload();const a=r.materialsInfo;for(let c in a)if(a.hasOwnProperty(c)){a[c];let l=r.materials[c];l.map.flipY=!1;const h=new X;h.setDecoderPath("./libs/encoder/"),h.setDecoderConfig({type:"js"}),h.setZip(t),h.load("TexturedMeshSimplified_"+c+".drc",(function(t){t.computeVertexNormals();const i=new e.Mesh(t,l);s.#s.add(i),n(o),h.dispose()}),i)}}))}loadFromID(e,t,n,o,s){let i=this;i.onProgress=o,i.zoomTo=s,this.#o.fetchRecords(e).then((function(e){if(e.hasErrors)n(e.errors[0]);else{var o=e.records[0],s=o.fields.title;null!=s&&t(s.value),o.fields.thumbnail.value.downloadURL;var r=o.fields.file.value.downloadURL;i.downloadZipFromURL(r)}})).catch((function(e){console.error("Failed to fetch record:",e)}))}}export{P as MTLLoader,H as OBJLoader,B as OrbitControls,X as UGBLoader,q as UGCloud};
//# sourceMappingURL=ugscan.min.js.map
