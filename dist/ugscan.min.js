import*as e from"three";import{Loader as t,LoaderUtils as o,FileLoader as n,RepeatWrapping as s,Color as i,MeshPhongMaterial as r,Vector2 as a,Texture as c,sRGBEncoding as l,Vector3 as h,Group as d,BufferGeometry as u,Float32BufferAttribute as p,LineBasicMaterial as m,Material as f,PointsMaterial as b,LineSegments as g,Points as y,Mesh as w,EventDispatcher as v,MOUSE as E,TOUCH as L,Quaternion as k,Spherical as T,SRGBColorSpace as O,LinearSRGBColorSpace as A,BufferAttribute as x}from"three";class P extends t{constructor(e){super(e)}load(e,t,s,i){const r=this,a=""===this.path?o.extractUrlBase(e):this.path,c=new n(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials);let l=this.fileMap.get(e);this.zip.file(l).async("string").then((function(o){try{t(r.parse(o,a))}catch(t){i?i(t):console.error(t),r.manager.itemError(e)}}),s,i)}setMaterialOptions(e){return this.materialOptions=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const o=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(o,e.files[t].name)}return this}parse(e,t){const o=e.split("\n");let n={};const s=/\s+/,i={};for(let e=0;e<o.length;e++){let t=o[e];if(t=t.trim(),0===t.length||"#"===t.charAt(0))continue;const r=t.indexOf(" ");let a=r>=0?t.substring(0,r):t;a=a.toLowerCase();let c=r>=0?t.substring(r+1):"";if(c=c.trim(),"newmtl"===a)n={name:c},i[c]=n;else if("ka"===a||"kd"===a||"ks"===a||"ke"===a){const e=c.split(s,3);n[a]=[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]}else n[a]=c}const r=new M(this.resourcePath||t,this.materialOptions);return r.setCrossOrigin(this.crossOrigin),r.setManager(this.manager),r.setMaterials(i),r.setFileMap(this.fileMap),r.setZip(this.zip),r}}class M{constructor(e="",t={}){this.baseUrl=e,this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.wrap=void 0!==this.options.wrap?this.options.wrap:s}setFileMap(e){this.fileMap=e}setZip(e){this.zip=e}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const t={};for(const o in e){const n=e[o],s={};t[o]=s;for(const e in n){let t=!0,o=n[e];const i=e.toLowerCase();switch(i){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(o=[o[0]/255,o[1]/255,o[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===o[0]&&0===o[1]&&0===o[2]&&(t=!1)}t&&(s[i]=o)}}return t}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray}create(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const t=this,o=this.materialsInfo[e],n={name:e,side:this.side};function s(e,o){if(n[e])return;const s=t.getTextureParams(o,n),i=t.loadTexture(s.url);i.repeat.copy(s.scale),i.offset.copy(s.offset),i.wrapS=t.wrap,i.wrapT=t.wrap,"map"!==e&&"emissiveMap"!==e||(i.encoding=l),n[e]=i}for(const e in o){const t=o[e];let r;if(""!==t)switch(e.toLowerCase()){case"kd":n.color=(new i).fromArray(t).convertSRGBToLinear();break;case"ks":n.specular=(new i).fromArray(t).convertSRGBToLinear();break;case"ke":n.emissive=(new i).fromArray(t).convertSRGBToLinear();break;case"map_kd":s("map",t);break;case"map_ks":s("specularMap",t);break;case"map_ke":s("emissiveMap",t);break;case"norm":s("normalMap",t);break;case"map_bump":case"bump":s("bumpMap",t);break;case"map_d":s("alphaMap",t),n.transparent=!0;break;case"ns":n.shininess=parseFloat(t);break;case"d":r=parseFloat(t),r<1&&(n.opacity=r,n.transparent=!0);break;case"tr":r=parseFloat(t),this.options&&this.options.invertTrProperty&&(r=1-r),r>0&&(n.opacity=1-r,n.transparent=!0)}}return this.materials[e]=new r(n),this.materials[e]}getTextureParams(e,t){const o={scale:new a(1,1),offset:new a(0,0)},n=e.split(/\s+/);let s;return s=n.indexOf("-bm"),s>=0&&(t.bumpScale=parseFloat(n[s+1]),n.splice(s,2)),s=n.indexOf("-s"),s>=0&&(o.scale.set(parseFloat(n[s+1]),parseFloat(n[s+2])),n.splice(s,4)),s=n.indexOf("-o"),s>=0&&(o.offset.set(parseFloat(n[s+1]),parseFloat(n[s+2])),n.splice(s,4)),o.url=n.join(" ").trim(),o}loadTexture(e,t,o,n,s){const i=new c;let r=this.fileMap.get(e);return this.zip.file(r).async("blob").then((e=>{const t=new Image;t.src=URL.createObjectURL(e),i.image=t,i.needsUpdate=!0,void 0!==o&&o(i)})),void 0!==t&&(i.mapping=t),i}}const j=/^[og]\s*(.+)?/,_=/^mtllib /,I=/^usemtl /,C=/^usemap /,R=/\s+/,D=new h,N=new h,S=new h,U=new h,F=new h,z=new i;function V(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const o=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const n={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==o?o.smooth:this.smooth,groupStart:void 0!==o?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(n),n},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},o&&o.name&&"function"==typeof o.clone){const e=o.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const o=parseInt(e,10);return 3*(o>=0?o-1:o+t/3)},parseNormalIndex:function(e,t){const o=parseInt(e,10);return 3*(o>=0?o-1:o+t/3)},parseUVIndex:function(e,t){const o=parseInt(e,10);return 2*(o>=0?o-1:o+t/2)},addVertex:function(e,t,o){const n=this.vertices,s=this.object.geometry.vertices;s.push(n[e+0],n[e+1],n[e+2]),s.push(n[t+0],n[t+1],n[t+2]),s.push(n[o+0],n[o+1],n[o+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,o){const n=this.normals,s=this.object.geometry.normals;s.push(n[e+0],n[e+1],n[e+2]),s.push(n[t+0],n[t+1],n[t+2]),s.push(n[o+0],n[o+1],n[o+2])},addFaceNormal:function(e,t,o){const n=this.vertices,s=this.object.geometry.normals;D.fromArray(n,e),N.fromArray(n,t),S.fromArray(n,o),F.subVectors(S,N),U.subVectors(D,N),F.cross(U),F.normalize(),s.push(F.x,F.y,F.z),s.push(F.x,F.y,F.z),s.push(F.x,F.y,F.z)},addColor:function(e,t,o){const n=this.colors,s=this.object.geometry.colors;void 0!==n[e]&&s.push(n[e+0],n[e+1],n[e+2]),void 0!==n[t]&&s.push(n[t+0],n[t+1],n[t+2]),void 0!==n[o]&&s.push(n[o+0],n[o+1],n[o+2])},addUV:function(e,t,o){const n=this.uvs,s=this.object.geometry.uvs;s.push(n[e+0],n[e+1]),s.push(n[t+0],n[t+1]),s.push(n[o+0],n[o+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,o,n,s,i,r,a,c){const l=this.vertices.length;let h=this.parseVertexIndex(e,l),d=this.parseVertexIndex(t,l),u=this.parseVertexIndex(o,l);if(this.addVertex(h,d,u),this.addColor(h,d,u),void 0!==r&&""!==r){const e=this.normals.length;h=this.parseNormalIndex(r,e),d=this.parseNormalIndex(a,e),u=this.parseNormalIndex(c,e),this.addNormal(h,d,u)}else this.addFaceNormal(h,d,u);if(void 0!==n&&""!==n){const e=this.uvs.length;h=this.parseUVIndex(n,e),d=this.parseUVIndex(s,e),u=this.parseUVIndex(i,e),this.addUV(h,d,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let o=0,n=e.length;o<n;o++){const n=this.parseVertexIndex(e[o],t);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const o=this.vertices.length,n=this.uvs.length;for(let t=0,n=e.length;t<n;t++)this.addVertexLine(this.parseVertexIndex(e[t],o));for(let e=0,o=t.length;e<o;e++)this.addUVLine(this.parseUVIndex(t[e],n))}};return e.startObject("",!1),e}let H=class extends t{constructor(e){super(e),this.materials=null}load(e,t,o,s){const i=this,r=new n(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);let a=this.fileMap.get(e);this.zip.file(a).async("uint8array").then((function(o){try{t(i.parse(o))}catch(t){s?s(t):console.error(t),i.manager.itemError(e)}}),o,s)}setMaterials(e){return this.materials=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const o=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(o,e.files[t].name)}return this}parse(e){const t=new V;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));const o=e.split("\n");let n=[];for(let e=0,s=o.length;e<s;e++){const s=o[e].trimStart();if(0===s.length)continue;const i=s.charAt(0);if("#"!==i)if("v"===i){const e=s.split(R);switch(e[0]){case"v":t.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?(z.setRGB(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6])).convertSRGBToLinear(),t.colors.push(z.r,z.g,z.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":t.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===i){const e=s.slice(1).trim().split(R),o=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n.length>0){const e=n.split("/");o.push(e)}}const n=o[0];for(let e=1,s=o.length-1;e<s;e++){const s=o[e],i=o[e+1];t.addFace(n[0],s[0],i[0],n[1],s[1],i[1],n[2],s[2],i[2])}}else if("l"===i){const e=s.substring(1).trim().split(" ");let o=[];const n=[];if(-1===s.indexOf("/"))o=e;else for(let t=0,s=e.length;t<s;t++){const s=e[t].split("/");""!==s[0]&&o.push(s[0]),""!==s[1]&&n.push(s[1])}t.addLineGeometry(o,n)}else if("p"===i){const e=s.slice(1).trim().split(" ");t.addPointGeometry(e)}else if(null!==(n=j.exec(s))){const e=(" "+n[0].slice(1).trim()).slice(1);t.startObject(e)}else if(I.test(s))t.object.startMaterial(s.substring(7).trim(),t.materialLibraries);else if(_.test(s))t.materialLibraries.push(s.substring(7).trim());else if(C.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===i){if(n=s.split(" "),n.length>1){const e=n[1].trim().toLowerCase();t.object.smooth="0"!==e&&"off"!==e}else t.object.smooth=!0;const e=t.object.currentMaterial();e&&(e.smooth=t.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}}t.finalize();const s=new d;s.materialLibraries=[].concat(t.materialLibraries);if(!0===!(1===t.objects.length&&0===t.objects[0].geometry.vertices.length))for(let e=0,o=t.objects.length;e<o;e++){const o=t.objects[e],n=o.geometry,i=o.materials,a="Line"===n.type,c="Points"===n.type;let l=!1;if(0===n.vertices.length)continue;const h=new u;h.setAttribute("position",new p(n.vertices,3)),n.normals.length>0&&h.setAttribute("normal",new p(n.normals,3)),n.colors.length>0&&(l=!0,h.setAttribute("color",new p(n.colors,3))),!0===n.hasUVIndices&&h.setAttribute("uv",new p(n.uvs,2));const d=[];for(let e=0,o=i.length;e<o;e++){const o=i[e],n=o.name+"_"+o.smooth+"_"+l;let s=t.materials[n];if(null!==this.materials)if(s=this.materials.create(o.name),!a||!s||s instanceof m){if(c&&s&&!(s instanceof b)){const e=new b({size:10,sizeAttenuation:!1});f.prototype.copy.call(e,s),e.color.copy(s.color),e.map=s.map,s=e}}else{const e=new m;f.prototype.copy.call(e,s),e.color.copy(s.color),s=e}void 0===s&&(s=a?new m:c?new b({size:1,sizeAttenuation:!1}):new r,s.name=o.name,s.flatShading=!o.smooth,s.vertexColors=l,t.materials[n]=s),d.push(s)}let v;if(d.length>1){for(let e=0,t=i.length;e<t;e++){const t=i[e];h.addGroup(t.groupStart,t.groupCount,e)}v=a?new g(h,d):c?new y(h,d):new w(h,d)}else v=a?new g(h,d[0]):c?new y(h,d[0]):new w(h,d[0]);v.name=o.name,s.add(v)}else if(t.vertices.length>0){const e=new b({size:1,sizeAttenuation:!1}),o=new u;o.setAttribute("position",new p(t.vertices,3)),t.colors.length>0&&void 0!==t.colors[0]&&(o.setAttribute("color",new p(t.colors,3)),e.vertexColors=!0);const n=new y(o,e);s.add(n)}return s}};const Y={type:"change"},G={type:"start"},Z={type:"end"};class B extends v{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new h,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:E.ROTATE,MIDDLE:E.DOLLY,RIGHT:E.PAN},this.touches={ONE:L.ROTATE,TWO:L.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",J),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",J),this._domElementKeyEvents=null},this.saveState=function(){o.target0.copy(o.target),o.position0.copy(o.object.position),o.zoom0=o.object.zoom},this.reset=function(){o.target.copy(o.target0),o.object.position.copy(o.position0),o.object.zoom=o.zoom0,o.object.updateProjectionMatrix(),o.dispatchEvent(Y),o.update(),s=n.NONE},this.update=function(){const t=new h,a=(new k).setFromUnitVectors(e.up,new h(0,1,0)),p=a.clone().invert(),m=new h,f=new k,b=2*Math.PI;return function(){const e=o.object.position;t.copy(e).sub(o.target),t.applyQuaternion(a),r.setFromVector3(t),o.autoRotate&&s===n.NONE&&M(2*Math.PI/60/60*o.autoRotateSpeed),o.enableDamping?(r.theta+=c.theta*o.dampingFactor,r.phi+=c.phi*o.dampingFactor):(r.theta+=c.theta,r.phi+=c.phi);let h=o.minAzimuthAngle,g=o.maxAzimuthAngle;return isFinite(h)&&isFinite(g)&&(h<-Math.PI?h+=b:h>Math.PI&&(h-=b),g<-Math.PI?g+=b:g>Math.PI&&(g-=b),r.theta=h<=g?Math.max(h,Math.min(g,r.theta)):r.theta>(h+g)/2?Math.max(h,r.theta):Math.min(g,r.theta)),r.phi=Math.max(o.minPolarAngle,Math.min(o.maxPolarAngle,r.phi)),r.makeSafe(),r.radius*=l,r.radius=Math.max(o.minDistance,Math.min(o.maxDistance,r.radius)),!0===o.enableDamping?o.target.addScaledVector(d,o.dampingFactor):o.target.add(d),t.setFromSpherical(r),t.applyQuaternion(p),e.copy(o.target).add(t),o.object.lookAt(o.target),!0===o.enableDamping?(c.theta*=1-o.dampingFactor,c.phi*=1-o.dampingFactor,d.multiplyScalar(1-o.dampingFactor)):(c.set(0,0,0),d.set(0,0,0)),l=1,!!(u||m.distanceToSquared(o.object.position)>i||8*(1-f.dot(o.object.quaternion))>i)&&(o.dispatchEvent(Y),m.copy(o.object.position),f.copy(o.object.quaternion),u=!1,!0)}}(),this.dispose=function(){o.domElement.removeEventListener("contextmenu",Q),o.domElement.removeEventListener("pointerdown",K),o.domElement.removeEventListener("pointercancel",W),o.domElement.removeEventListener("wheel",q),o.domElement.removeEventListener("pointermove",X),o.domElement.removeEventListener("pointerup",W),null!==o._domElementKeyEvents&&(o._domElementKeyEvents.removeEventListener("keydown",J),o._domElementKeyEvents=null)};const o=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=n.NONE;const i=1e-6,r=new T,c=new T;let l=1;const d=new h;let u=!1;const p=new a,m=new a,f=new a,b=new a,g=new a,y=new a,w=new a,v=new a,O=new a,A=[],x={};function P(){return Math.pow(.95,o.zoomSpeed)}function M(e){c.theta-=e}function j(e){c.phi-=e}const _=function(){const e=new h;return function(t,o){e.setFromMatrixColumn(o,0),e.multiplyScalar(-t),d.add(e)}}(),I=function(){const e=new h;return function(t,n){!0===o.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(o.object.up,e)),e.multiplyScalar(t),d.add(e)}}(),C=function(){const e=new h;return function(t,n){const s=o.domElement;if(o.object.isPerspectiveCamera){const i=o.object.position;e.copy(i).sub(o.target);let r=e.length();r*=Math.tan(o.object.fov/2*Math.PI/180),_(2*t*r/s.clientHeight,o.object.matrix),I(2*n*r/s.clientHeight,o.object.matrix)}else o.object.isOrthographicCamera?(_(t*(o.object.right-o.object.left)/o.object.zoom/s.clientWidth,o.object.matrix),I(n*(o.object.top-o.object.bottom)/o.object.zoom/s.clientHeight,o.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),o.enablePan=!1)}}();function R(e){o.object.isPerspectiveCamera?l/=e:o.object.isOrthographicCamera?(o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom*e)),o.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function D(e){o.object.isPerspectiveCamera?l*=e:o.object.isOrthographicCamera?(o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom/e)),o.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function N(e){p.set(e.clientX,e.clientY)}function S(e){b.set(e.clientX,e.clientY)}function U(){if(1===A.length)p.set(A[0].pageX,A[0].pageY);else{const e=.5*(A[0].pageX+A[1].pageX),t=.5*(A[0].pageY+A[1].pageY);p.set(e,t)}}function F(){if(1===A.length)b.set(A[0].pageX,A[0].pageY);else{const e=.5*(A[0].pageX+A[1].pageX),t=.5*(A[0].pageY+A[1].pageY);b.set(e,t)}}function z(){const e=A[0].pageX-A[1].pageX,t=A[0].pageY-A[1].pageY,o=Math.sqrt(e*e+t*t);w.set(0,o)}function V(e){if(1==A.length)m.set(e.pageX,e.pageY);else{const t=ee(e),o=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);m.set(o,n)}f.subVectors(m,p).multiplyScalar(o.rotateSpeed);const t=o.domElement;M(2*Math.PI*f.x/t.clientHeight),j(2*Math.PI*f.y/t.clientHeight),p.copy(m)}function H(e){if(1===A.length)g.set(e.pageX,e.pageY);else{const t=ee(e),o=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);g.set(o,n)}y.subVectors(g,b).multiplyScalar(o.panSpeed),C(y.x,y.y),b.copy(g)}function B(e){const t=ee(e),n=e.pageX-t.x,s=e.pageY-t.y,i=Math.sqrt(n*n+s*s);v.set(0,i),O.set(0,Math.pow(v.y/w.y,o.zoomSpeed)),R(O.y),w.copy(v)}function K(e){!1!==o.enabled&&(0===A.length&&(o.domElement.setPointerCapture(e.pointerId),o.domElement.addEventListener("pointermove",X),o.domElement.addEventListener("pointerup",W)),function(e){A.push(e)}(e),"touch"===e.pointerType?function(e){switch($(e),A.length){case 1:switch(o.touches.ONE){case L.ROTATE:if(!1===o.enableRotate)return;U(),s=n.TOUCH_ROTATE;break;case L.PAN:if(!1===o.enablePan)return;F(),s=n.TOUCH_PAN;break;default:s=n.NONE}break;case 2:switch(o.touches.TWO){case L.DOLLY_PAN:if(!1===o.enableZoom&&!1===o.enablePan)return;o.enableZoom&&z(),o.enablePan&&F(),s=n.TOUCH_DOLLY_PAN;break;case L.DOLLY_ROTATE:if(!1===o.enableZoom&&!1===o.enableRotate)return;o.enableZoom&&z(),o.enableRotate&&U(),s=n.TOUCH_DOLLY_ROTATE;break;default:s=n.NONE}break;default:s=n.NONE}s!==n.NONE&&o.dispatchEvent(G)}(e):function(e){let t;switch(e.button){case 0:t=o.mouseButtons.LEFT;break;case 1:t=o.mouseButtons.MIDDLE;break;case 2:t=o.mouseButtons.RIGHT;break;default:t=-1}switch(t){case E.DOLLY:if(!1===o.enableZoom)return;!function(e){w.set(e.clientX,e.clientY)}(e),s=n.DOLLY;break;case E.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===o.enablePan)return;S(e),s=n.PAN}else{if(!1===o.enableRotate)return;N(e),s=n.ROTATE}break;case E.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===o.enableRotate)return;N(e),s=n.ROTATE}else{if(!1===o.enablePan)return;S(e),s=n.PAN}break;default:s=n.NONE}s!==n.NONE&&o.dispatchEvent(G)}(e))}function X(e){!1!==o.enabled&&("touch"===e.pointerType?function(e){switch($(e),s){case n.TOUCH_ROTATE:if(!1===o.enableRotate)return;V(e),o.update();break;case n.TOUCH_PAN:if(!1===o.enablePan)return;H(e),o.update();break;case n.TOUCH_DOLLY_PAN:if(!1===o.enableZoom&&!1===o.enablePan)return;!function(e){o.enableZoom&&B(e),o.enablePan&&H(e)}(e),o.update();break;case n.TOUCH_DOLLY_ROTATE:if(!1===o.enableZoom&&!1===o.enableRotate)return;!function(e){o.enableZoom&&B(e),o.enableRotate&&V(e)}(e),o.update();break;default:s=n.NONE}}(e):function(e){switch(s){case n.ROTATE:if(!1===o.enableRotate)return;!function(e){m.set(e.clientX,e.clientY),f.subVectors(m,p).multiplyScalar(o.rotateSpeed);const t=o.domElement;M(2*Math.PI*f.x/t.clientHeight),j(2*Math.PI*f.y/t.clientHeight),p.copy(m),o.update()}(e);break;case n.DOLLY:if(!1===o.enableZoom)return;!function(e){v.set(e.clientX,e.clientY),O.subVectors(v,w),O.y>0?R(P()):O.y<0&&D(P()),w.copy(v),o.update()}(e);break;case n.PAN:if(!1===o.enablePan)return;!function(e){g.set(e.clientX,e.clientY),y.subVectors(g,b).multiplyScalar(o.panSpeed),C(y.x,y.y),b.copy(g),o.update()}(e)}}(e))}function W(e){!function(e){delete x[e.pointerId];for(let t=0;t<A.length;t++)if(A[t].pointerId==e.pointerId)return void A.splice(t,1)}(e),0===A.length&&(o.domElement.releasePointerCapture(e.pointerId),o.domElement.removeEventListener("pointermove",X),o.domElement.removeEventListener("pointerup",W)),o.dispatchEvent(Z),s=n.NONE}function q(e){!1!==o.enabled&&!1!==o.enableZoom&&s===n.NONE&&(e.preventDefault(),o.dispatchEvent(G),function(e){e.deltaY<0?D(P()):e.deltaY>0&&R(P()),o.update()}(e),o.dispatchEvent(Z))}function J(e){!1!==o.enabled&&!1!==o.enablePan&&function(e){let t=!1;switch(e.code){case o.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?j(2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):C(0,o.keyPanSpeed),t=!0;break;case o.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?j(-2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):C(0,-o.keyPanSpeed),t=!0;break;case o.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?M(2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):C(o.keyPanSpeed,0),t=!0;break;case o.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?M(-2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):C(-o.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),o.update())}(e)}function Q(e){!1!==o.enabled&&e.preventDefault()}function $(e){let t=x[e.pointerId];void 0===t&&(t=new a,x[e.pointerId]=t),t.set(e.pageX,e.pageY)}function ee(e){const t=e.pointerId===A[0].pointerId?A[1]:A[0];return x[t.pointerId]}o.domElement.addEventListener("contextmenu",Q),o.domElement.addEventListener("pointerdown",K),o.domElement.addEventListener("pointercancel",W),o.domElement.addEventListener("wheel",q,{passive:!1}),this.update()}}const K=new WeakMap;class X extends t{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}setZip(e){this.zip=e,this.fileMap=new Map;for(const t in e.files)if(Object.prototype.hasOwnProperty.call(e.files,t)){const o=t.substring(t.lastIndexOf("/")+1);this.fileMap.set(o,e.files[t].name)}return this}load(e,t,o,n){var s=this;let i=this.fileMap.get(e);s.zip.file(i).async("arraybuffer").then((function(e){console.log(i),console.log("This: ",s),s.parse(e,t,n)}),o,n)}parse(e,t,o){this.decodeDracoFile(e,t,null,null,O).catch(o)}decodeDracoFile(e,t,o,n,s=A){const i={attributeIDs:o||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!o,vertexColorSpace:s};return this.decodeGeometry(e,i).then(t)}decodeGeometry(e,t){const o=JSON.stringify(t);if(K.has(e)){const t=K.get(e);if(t.key===o)return t.promise;if(0===e.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const s=this.workerNextTaskID++,i=e.byteLength,r=this._getWorker(s,i).then((o=>(n=o,new Promise(((o,i)=>{n._callbacks[s]={resolve:o,reject:i},n.postMessage({type:"decode",id:s,taskConfig:t,buffer:e},[e])}))))).then((e=>this._createGeometry(e.geometry)));return r.catch((()=>!0)).then((()=>{n&&s&&this._releaseTask(n,s)})),K.set(e,{key:o,promise:r}),r}_createGeometry(e){const t=new u;e.index&&t.setIndex(new x(e.index.array,1));for(let o=0;o<e.attributes.length;o++){const n=e.attributes[o],s=n.name,i=n.array,r=n.itemSize,a=new x(i,r);"color"===s&&this._assignVertexColorSpace(a,n.vertexColorSpace),t.setAttribute(s,a)}return t}_assignVertexColorSpace(e,t){if(t!==O)return;const o=new i;for(let t=0,n=e.count;t<n;t++)o.fromBufferAttribute(e,t).convertSRGBToLinear(),e.setXYZ(t,o.r,o.g,o.b)}_loadLibrary(e,t){const o=new n(this.manager);return o.setPath(this.decoderPath),o.setResponseType(t),o.setWithCredentials(this.withCredentials),new Promise(((t,n)=>{o.load(e,t,void 0,n)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then((t=>{const o=t[0];e||(this.decoderConfig.wasmBinary=t[1]);const n=W.toString(),s=["/* draco decoder */",o,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([s]))})),this.decoderPending}_getWorker(e,t){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",decoderConfig:this.decoderConfig}),e.onmessage=function(t){const o=t.data;switch(o.type){case"decode":e._callbacks[o.id].resolve(o);break;case"error":e._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const o=this.workerPool[this.workerPool.length-1];return o._taskCosts[e]=t,o._taskLoad+=t,o}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function W(){let e,t;function o(e,t,o,n,s,i){const r=i.num_components(),a=o.num_points()*r,c=a*s.BYTES_PER_ELEMENT,l=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),h=e._malloc(c);t.GetAttributeDataArrayForAllPoints(o,i,l,c,h);const d=new s(e.HEAPF32.buffer,h,a).slice();return e._free(h),{name:n,array:d,itemSize:r}}onmessage=function(n){const s=n.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const n=s.buffer,i=s.taskConfig;t.then((e=>{const t=e.draco,r=new t.Decoder;try{const e=function(e,t,n,s){const i=s.attributeIDs,r=s.attributeTypes;let a,c;const l=t.GetEncodedGeometryType(n);if(l===e.TRIANGULAR_MESH)a=new e.Mesh,c=t.DecodeArrayToMesh(n,n.byteLength,a);else{if(l!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");a=new e.PointCloud,c=t.DecodeArrayToPointCloud(n,n.byteLength,a)}if(!c.ok()||0===a.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const h={index:null,attributes:[]};for(const n in i){const c=self[r[n]];let l,d;if(s.useUniqueIDs)d=i[n],l=t.GetAttributeByUniqueId(a,d);else{if(d=t.GetAttributeId(a,e[i[n]]),-1===d)continue;l=t.GetAttribute(a,d)}const u=o(e,t,a,n,c,l);"color"===n&&(u.vertexColorSpace=s.vertexColorSpace),h.attributes.push(u)}l===e.TRIANGULAR_MESH&&(h.index=function(e,t,o){const n=o.num_faces(),s=3*n,i=4*s,r=e._malloc(i);t.GetTrianglesUInt32Array(o,i,r);const a=new Uint32Array(e.HEAPF32.buffer,r,s).slice();return e._free(r),{array:a,itemSize:1}}(e,t,a));return e.destroy(a),h}(t,r,new Int8Array(n),i),a=e.attributes.map((e=>e.array.buffer));e.index&&a.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},a)}catch(e){console.error(e),self.postMessage({type:"error",id:s.id,error:e.message})}finally{t.destroy(r)}}))}}}class q{#e="a1811cf9d60cd523954f5ec40bcb1004d8322d4e75b8cfd09a9fd2dd9904d88e";#t="6d15b55292b430789704bb164179efd98fb146c5d123f3ad0285f47364fc0657";#o=null;#n=null;#s=null;constructor(e){this.#s=e}initConfig(e){var t,o;e?(t=CloudKit.DEVELOPMENT_ENVIRONMENT,o=this.#e):(t=CloudKit.PRODUCTION_ENVIRONMENT,o=this.#t),CloudKit.configure({containers:[{containerIdentifier:"iCloud.com.ugscan",apiTokenAuth:{apiToken:o},environment:t}]}),this.#o=CloudKit.getDefaultContainer(),this.#n=this.#o.publicCloudDatabase}downloadZipFromURL(e){let t=this;new JSZip,fetch(e).then((e=>{const o=e.headers.get("content-length");let n=0;const s=e.body.getReader(),i=[];!function e(){s.read().then((({done:s,value:r})=>{if(s){const e=new Blob(i),o=new FileReader;return o.onload=function(){(new JSZip).loadAsync(o.result).then((e=>{t.loadUGB(e,t.zoomTo,t.#s)}))},void o.readAsArrayBuffer(e)}i.push(r),n+=r.byteLength,t.onProgress(n,o),e()})).catch((e=>{console.error(e)}))}()})).catch((e=>{console.error(e)}))}loadOBJ(e){const t=function(e){if(e.lengthComputable){const t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% downloaded")}};(new P).setZip(e).load("TexturedMeshSimplified.mtl",(function(o){o.preload(),(new OBJLoader).setMaterials(o).setZip(e).load("TexturedMeshSimplified.obj",(function(e){scene.add(e),zoomTo(e)}),t)}))}loadUGB(t,o,n){let s=this;const i=function(e){if(e.lengthComputable){const t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% downloaded")}};(new P).setZip(t).load("TexturedMeshSimplified.mtl",(function(r){r.preload();const a=r.materialsInfo;for(let c in a)if(a.hasOwnProperty(c)){a[c];let l=r.materials[c];l.map.flipY=!1;const h=new X;h.setDecoderPath("./libs/encoder/"),h.setDecoderConfig({type:"js"}),h.setZip(t),h.load("TexturedMeshSimplified_"+c+".drc",(function(t){console.log(c),t.computeVertexNormals();const i=new e.Mesh(t,l);s.#s.add(i),o(n),h.dispose()}),i)}}))}loadFromID(e,t,o,n,s){let i=this;i.onProgress=n,i.zoomTo=s,this.#n.fetchRecords(e).then((function(e){if(e.hasErrors)o(e.errors[0]);else{var n=e.records[0],s=n.fields.title;null!=s&&t(s.value),n.fields.thumbnail.value.downloadURL;var r=n.fields.file.value.downloadURL;i.downloadZipFromURL(r)}})).catch((function(e){console.error("Failed to fetch record:",e)}))}}export{P as MTLLoader,H as OBJLoader,B as OrbitControls,X as UGBLoader,q as UGCloud};
//# sourceMappingURL=ugscan.min.js.map
